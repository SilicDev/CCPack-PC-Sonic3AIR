//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
    if (no_jump_timer > 0)
    {
        CrowdControl.updateNoJumpTimer()
        return false
    }
    return base.Character.CheckStartJump()
}

//# address-hook(0x016e60)
function void fn016e60() //Character.KnucklesWallIdleUpdate
{
    // Climbing idle state update
    char.animation.timer = 0x20
    char.animation.frame = 0
    if (control.player1 & CONTROL_ABC && no_jump_timer == 0)
    {
        // Knuckles jumping off the wall
        char.velocity.y = -0x380
        char.velocity.x = 0x400
        char.flags ^= char.flag.FACING_LEFT
        if (char.flags & char.flag.FACING_LEFT)
            char.velocity.x = -char.velocity.x

        char.flags |= (char.flag.IN_AIR | char.flag.ROLLING)
        char.state = char.state.ROLLING
        char.jumping = 1
        char.hitbox_extends.x = char.hitbox.x.ROLLING
        char.hitbox_extends.y = char.hitbox.y.ROLLING
        char.double_jump_state = 0        // Allow gliding again
    }
    if (no_jump_timer > 0)
    {
        CrowdControl.updateNoJumpTimer()
    }
}

function void Character.updateJumpMoves()
{
    if (no_jump_ability_timer > 0)
    {
        return
    }
    base.Character.updateJumpMoves()
}

//# address-hook(0x01ab6c) end(0x01ab92)
function void Character.UpdateMovement()
{
    UpdateMovementStraight()
    u16 gravity = char.flags & char.flag.UNDERWATER ? 0x10 : 0x38
    char.velocity.y += CrowdControl.calculateGravity(gravity)
}

//# address-hook(0x011036) end(0x01105e)
function void Character.UpdateSonicRollingInAir()
{
    UpdateSonicJumpMoves()
    Character.UpdateControlInAir()
    Character.CheckAgainstMoveBorders()
    Character.UpdateMovement()

    Character.UpdateRotationInAir()
    Character.CheckCollision()
}

function void updateTailsInAir_shared()
{
    UpdateTailsJumpMoves()
    Character.UpdateControlInAir()
    Character.CheckAgainstMoveBorders()
    Character.UpdateMovement()

    Character.UpdateRotationInAir()
    Character.CheckCollision()
}
//# address-hook(0x017118) end(0x017140)
function void Character.UpdateKnucklesRollingInAir()
{
    UpdateKnucklesJumpMoves()
    Character.UpdateControlInAir()
    Character.CheckAgainstMoveBorders()
    Character.UpdateMovement()

    Character.UpdateRotationInAir()
    Character.CheckCollision()
}

//# address-hook(0x010868) end(0x010894)
//# alias(fn010868) deprecated
function void CompetitionMode.Character.UpdateUprightInAir.Sonic_Knuckles()
{
    UpdateSonicJumpMoves()
    Character.UpdateControlInAir()
    UpdateMovementSimple()


    Character.UpdateRotationInAir()
    pushA456()
    Character.CheckCollision()
    popA456()
}

//# address-hook(0x01335a) end(0x0133ac)
//# alias(fn01335a) deprecated
function void CompetitionMode.Character.UpdateUprightInAir.Tails()
{
    if (char.double_jump_state == 0)
    {
        UpdateTailsJumpMoves()
        Character.UpdateControlInAir()
        UpdateMovementSimple()
    }
    else
    {
        fn0133ae()
        Character.UpdateControlInAir()
        UpdateMovementStraightSimple()
    }

    Character.UpdateRotationInAir()
    pushA456()
    Character.CheckCollision()
    popA456()
}

//# address-hook(0x01348c) end(0x0134b8)
//# alias(fn01348c) deprecated
function void CompetitionMode.Character.UpdateRollingInAir.Tails()
{
    UpdateTailsJumpMoves()
    Character.UpdateControlInAir()
    UpdateMovementSimple()

    Character.UpdateRotationInAir()
    pushA456()
    Character.CheckCollision()
    popA456()
}

// If this was a function split into multiple components, I wouldn't have to overwrite it like this
// alas, let's pray it doesn't break any character mods
//# address-hook(0x016890) end(0x016c78)
//# translated(0x016f6c) end(0x016fa6)
function void UpdateKnucklesGlideCollision()
{
    if (char.double_jump_state == 0)
        return

    D0.u8 = char.double_jump_state
    if (char.double_jump_state == 1 || char.double_jump_state > 5)    // Last check is probably not needed, just added for full compatibility
    {
        // Gliding/Climbing state
        fn01793e()
        if (knuckles.glideclimbstate & 0x02)    // Gliding?
        {
            if (knuckles.glideclimbstate & 0x20)    // Climbing?
            {
                if ((knuckles.preventclimbing & 0x80) == 0)
                {
                    bool hit_wall = true
                    D5.u8 = char.layer_flags2
                    D0.u8 = knuckles.glide_direction + 0x40
                    if (D0.s8 < 0)
                    {
                        char.flags |= char.flag.FACING_LEFT
                        CheckHitboxCollisionLeft()

                        D1.u16 |= D0.u16
                        if (D1.u16 != 0)
                        {
                            D3.u16 = char.position.x.u16 - s8(char.hitbox_extends.y) - 1

                            if (global.inv_gravity == 0)
                            {
                                D2.u16 = char.position.y.u16 - 11
                                Character.checkFloorEdgeCollisionFixedY()
                                if (D1.s16 < 0 || D1.u16 >= 12)
                                {
                                    hit_wall = false
                                }
                                else
                                {
                                    char.position.y.u16 += D1.u16
                                }
                            }
                            else
                            {
                                D2.u16 = (char.position.y.u16 + 11) ^ 0x0f
                                Character.checkCeilingEdgeCollisionFixedY()
                                if (D1.s16 < 0 || D1.u16 >= 12)
                                {
                                    hit_wall = false
                                }
                                else
                                {
                                    char.position.y.u16 -= D1.u16
                                }
                            }
                        }
                        else
                        {
                            ++char.position.x.u16
                        }
                    }
                    else
                    {
                        char.flags &= ~char.flag.FACING_LEFT
                        CheckHitboxCollisionRight()

                        D1.u16 |= D0.u16
                        if (D1.u16 != 0)
                        {
                            D3.u16 = char.position.x.u16 + s8(char.hitbox_extends.y) + 1

                            if (global.inv_gravity == 0)
                            {
                                D2.u16 = char.position.y.u16 - 11
                                Character.checkFloorEdgeCollisionFixedY()
                                if (D1.s16 < 0 || D1.u16 >= 12)
                                {
                                    hit_wall = false
                                }
                                else
                                {
                                    char.position.y.u16 += D1.u16
                                }
                            }
                            else
                            {
                                D2.u16 = (char.position.y.u16 + 11) ^ 0x0f
                                Character.checkCeilingEdgeCollisionFixedY()
                                if (D1.s16 < 0 || D1.u16 >= 12)
                                {
                                    hit_wall = false
                                }
                                else
                                {
                                    char.position.y.u16 -= D1.u16
                                }
                            }
                        }
                    }

                    if (hit_wall)
                    {
                        // When Hyper Knuckles hits a wall fast enough, that kills all badniks on screen
                        if ((super.active & 0x80) && u16(char.groundspeed) >= 0x480)
                        {
                            camera.hyper_knux_shake = 0x14
                            Character.ClearEnemiesOnScreen()
                            playSound(0x49)
                            #if STANDALONE
                            Input.setControllerRumbleByAddress(A0, 0.5f, 1.0f, 200)
                            #endif
                        }
                        else
                        {
                            playSound(SFX_GRAB)
                            #if STANDALONE
                            Input.setControllerRumbleByAddress(A0, 0.5f, 0.0f, 200)
                            #endif
                        }

                        char.groundspeed = 0
                        char.velocity.x = 0
                        char.velocity.y = 0
                        char.double_jump_state = 4        // Knuckles climbing state
                        char.animation.sprite = 0xb7
                        char.animation.timer = 0x7f
                        char.animation.frame = 0
                        knuckles.glide_direction = 3
                        char.position.x.frac = char.position.x.u16

                        #if STANDALONE
                        // Prevent Knuckles from climbing above the screen limits
                        //  -> This same check is down while climbing up/down, but we do it here to correct the position right away
                        //  -> This is added for S3AIR specifically because it's now much easier to get outside the screen after we removed the stopping effect when gliding the the top of screen (see "UpdateKnucklesGlide")
                        if (level.vertical_wrap != 0xff00)
                        {
                            s16 minY = level.vertical_wrap + 0x10
                            if (s16(char.position.y.u16) < minY)
                            {
                                char.position.y.u16 = minY
                            }
                        }
                        #endif
                        return
                    }
                }

                char.double_jump_state = 2        // Knuckles glide drop state
                char.state = char.state.KNUX_FALLING
                char.hitbox_extends.x = char.hitbox.default.x
                char.hitbox_extends.y = char.hitbox.default.y
                knuckles.glideclimbstate |= 0x02
                return
            }

            if (control.player1.state & CONTROL_ABC && no_jump_ability_timer == 0)
            {
                fn016fa8()
            }
            else
            {
                // Stop gliding
                char.double_jump_state = 2        // Knuckles glide drop state
                char.state = char.state.KNUX_FALLING
                if (char.velocity.x < 0)
                    char.flags |= char.flag.FACING_LEFT
                else
                    char.flags &= ~char.flag.FACING_LEFT

                char.velocity.x >>= 2
                char.hitbox_extends.x = char.hitbox.default.x
                char.hitbox_extends.y = char.hitbox.default.y

                #if STANDALONE
                // Perform a ground collision check after updating the hitbox height
                //  -> This prevents getting killed when Knuckles stops gliding just above the floor and there's a blocker object right underneath
                Character.CheckFloorCollision()
                if (D1.s16 < 0)
                {
                    char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
                }
                #endif
            }
        }
        else
        {
            if (char.velocity.x < 0)
                char.flags |= char.flag.FACING_LEFT
            else
                char.flags &= ~char.flag.FACING_LEFT

            D0.u8 = (char.rotation + 0x20) & 0xc0
            if (D0.u8 != 0)
            {
                char.velocity.x = char.groundspeed
                char.velocity.y = 0
                Character.LandingOnGroundNoSpindash()
            }
            else
            {
                char.double_jump_state = 3        // Knuckles ground slide state
                char.animation.sprite = 0xcc
                char.animation.timer = 0x7f
                char.animation.frame = 0
                if (char.drown_countdown >= 12)
                {
                    u8[A6 + 0x05] = 0x06        // Base update for braking dust
                    u8[A6 + 0x22] = 0x15        // First frame of dust animation
                }
            }
        }
    }
    else if (char.double_jump_state == 2)
    {
        // Falling state
        Character.UpdateControlInAir()

        // Gravity
        u16 gravity = (char.flags & char.flag.UNDERWATER) ? 0x10 : 0x38
        char.velocity.y += CrowdControl.calculateGravity(gravity)

        fn01793e()
        if ((knuckles.glideclimbstate & 0x02) == 0)
        {
            char.groundspeed = 0
            char.velocity.x = 0
            char.velocity.y = 0
            s16 dy = s8(char.hitbox_extends.y - char.hitbox.default.y)
            char.position.y.u16 += global.inv_gravity ? -dy : dy
            playSound(0x4c)

            D0.u8 = (char.rotation + 0x20) & 0xc0
            if (D0.u8 != 0)
            {
                Character.LandingOnGroundNoSpindash()
            }
            else
            {
                Character.LandingOnGroundNoSpindash()
                char.hlock_countdown = 15
                char.state = char.state.KNUX_STANDUP2
            }
        }
    }
    else if (char.double_jump_state == 3)
    {
        // Touched ground while gliding
        bool goto016b64 = false
        if (control.player1.state & CONTROL_ABC)
        {
            if (char.velocity.x < 0)
            {
                char.velocity.x += 0x20
                goto016b64 = (char.velocity.x < 0)
            }
            else
            {
                char.velocity.x -= 0x20
                goto016b64 = (char.velocity.x >= 0)
            }
        }

        if (goto016b64)
        {
            fn01793e()
            Character.CheckFloorCollision()
            if (D1.s16 < 0x0e)
            {
                char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
                char.rotation = D3.u8
                if ((level.framecounter.low & 0x07) == 0)
                {
                    playSound(0x7e)
                }
                #if STANDALONE
                Input.setControllerRumbleByAddress(A0, 0.2f, 0.2f, 100)
                #endif
            }
            else
            {
                char.double_jump_state = 2        // Knuckles glide drop state
                char.state = char.state.KNUX_FALLING
                char.hitbox_extends.x = char.hitbox.default.x
                char.hitbox_extends.y = char.hitbox.default.y
                knuckles.glideclimbstate |= 0x02
            }
        }
        else
        {
            char.groundspeed = 0
            char.velocity.x = 0
            char.velocity.y = 0
            s16 dy = s8(char.hitbox_extends.y - char.hitbox.default.y)
            char.position.y.u16 += global.inv_gravity ? -dy : dy
            Character.LandingOnGroundNoSpindash()
            char.hlock_countdown = 15
            char.state = char.state.KNUX_STANDUP
        }
    }
    else if (char.double_jump_state == 4)
    {
        // Climbing state
        if (knuckles.preventclimbing & 0x80 || char.position.x.u16 != char.position.x.frac || (char.flags & char.flag.ON_OBJECT))
        {
            fn016ed2()
            return
        }

        char.groundspeed = 0
        char.velocity.x = 0
        char.velocity.y = 0
        u32[0xfffff796] = (char.layer_flags2 == 0x0d) ? u32[0xfffff7b4] : u32[0xfffff7b8]
        D5.u8 = char.layer_flags2
        D1 = 0

        if ((control.player1.state & CONTROL_UP) == 0)
        {
            fn016d10()
            return
        }

        // Knuckles climbing up
        if (global.inv_gravity)
        {
            fn016da8()
            return
        }

        D2.u16 = char.position.y.u16 - 11
        fn016f4e()
        if (D1.s16 >= 4)
        {
            fn016eba()
            return
        }

        if (D1.u16 != 0)
        {
            fn016e60()
        }

        D5.u8 = char.layer_flags2
        D2.u16 = char.position.y.u16 - 8
        D3.u16 = char.position.x.u16
        fn00fbee()
        if (D1.s16 < 0)
        {
            char.position.y.u16 -= D1.u16
            D1 = 1
        }
        else
        {
            --char.position.y.u16
            if (super.active)
                --char.position.y.u16

            D1 = 1
            if (level.vertical_wrap != 0xff00)
            {
                s16 minY = level.vertical_wrap + 0x10
                if (s16(char.position.y.u16) < minY)
                {
                    char.position.y.u16 = minY
                }
            }
        }
        fn016e10()
    }
    else if (char.double_jump_state == 5)
    {
        // Climbing up a ledge
        if (char.animation.timer == 0)
        {
            fn016efe()
            if (knuckles.glide_direction == 0x10)
            {
                char.groundspeed = 0
                char.velocity.x = 0
                char.velocity.y = 0
                if (char.flags & char.flag.FACING_LEFT)
                    --char.position.x.u16

                Character.LandingOnGroundNoSpindash()
                char.state = char.state.STANDING
            }
        }
    }
}