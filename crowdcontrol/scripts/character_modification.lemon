//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
    if (no_jump_timer > 0)
    {
        return false
    }
    return base.Character.CheckStartJump()
}

//# address-hook(0x016e60)
function void fn016e60() //Character.KnucklesWallIdleUpdate
{
    // Climbing idle state update
    char.animation.timer = 0x20
    char.animation.frame = 0
    if (control.player1 & CONTROL_ABC && no_jump_timer == 0)
    {
        // Knuckles jumping off the wall
        char.velocity.y = -0x380
        char.velocity.x = 0x400
        char.flags ^= char.flag.FACING_LEFT
        if (char.flags & char.flag.FACING_LEFT)
            char.velocity.x = -char.velocity.x

        char.flags |= (char.flag.IN_AIR | char.flag.ROLLING)
        char.state = char.state.ROLLING
        char.jumping = 1
        char.hitbox_extends.x = char.hitbox.x.ROLLING
        char.hitbox_extends.y = char.hitbox.y.ROLLING
        char.double_jump_state = 0        // Allow gliding again
    }
}

function void Character.updateJumpMoves()
{
    if (no_jump_ability_timer > 0)
    {
        return
    }
    base.Character.updateJumpMoves()
}

//# address-hook(0x01ab6c) end(0x01ab92)
function void Character.UpdateMovement()
{
    UpdateMovementStraight()
    u16 gravity = char.flags & char.flag.UNDERWATER ? 0x10 : 0x38
    char.velocity.y += CrowdControl.calculateGravity(gravity)
}

//# address-hook(0x011036) end(0x01105e)
function void Character.UpdateSonicRollingInAir()
{
    UpdateSonicJumpMoves()
    Character.UpdateControlInAir()
    Character.CheckAgainstMoveBorders()
    Character.UpdateMovement()

    Character.UpdateRotationInAir()
    Character.CheckCollision()
}

function void updateTailsInAir_shared()
{
    UpdateTailsJumpMoves()
    Character.UpdateControlInAir()
    Character.CheckAgainstMoveBorders()
    Character.UpdateMovement()

    Character.UpdateRotationInAir()
    Character.CheckCollision()
}
//# address-hook(0x017118) end(0x017140)
function void Character.UpdateKnucklesRollingInAir()
{
    UpdateKnucklesJumpMoves()
    Character.UpdateControlInAir()
    Character.CheckAgainstMoveBorders()
    Character.UpdateMovement()

    Character.UpdateRotationInAir()
    Character.CheckCollision()
}

//# address-hook(0x010868) end(0x010894)
//# alias(fn010868) deprecated
function void CompetitionMode.Character.UpdateUprightInAir.Sonic_Knuckles()
{
    UpdateSonicJumpMoves()
    Character.UpdateControlInAir()
    UpdateMovementSimple()


    Character.UpdateRotationInAir()
    pushA456()
    Character.CheckCollision()
    popA456()
}

//# address-hook(0x01335a) end(0x0133ac)
//# alias(fn01335a) deprecated
function void CompetitionMode.Character.UpdateUprightInAir.Tails()
{
    if (char.double_jump_state == 0)
    {
        UpdateTailsJumpMoves()
        Character.UpdateControlInAir()
        UpdateMovementSimple()
    }
    else
    {
        fn0133ae()
        Character.UpdateControlInAir()
        UpdateMovementStraightSimple()
    }

    Character.UpdateRotationInAir()
    pushA456()
    Character.CheckCollision()
    popA456()
}

//# address-hook(0x01348c) end(0x0134b8)
//# alias(fn01348c) deprecated
function void CompetitionMode.Character.UpdateRollingInAir.Tails()
{
    UpdateTailsJumpMoves()
    Character.UpdateControlInAir()
    UpdateMovementSimple()

    Character.UpdateRotationInAir()
    pushA456()
    Character.CheckCollision()
    popA456()
}

global s16 knuckles_glide_collision_vY

//# address-hook(0x016890) end(0x016c78)
//# translated(0x016f6c) end(0x016fa6)
function void UpdateKnucklesGlideCollision()
{
    // capture knuckles vY before execution
    knuckles_glide_collision_vY = char.velocity.y 
    base.UpdateKnucklesGlideCollision()
}

// this function is called from 3 points from inside UpdateKnucklesGlideCollision()
// however only one of those points should happen after a vY change
// and it happens immediatel after so we check if velocity has changed 
// and if it has, undo it and apply our own gravity logic then the function
// will continue as normal, with the modified gravity
//# address-hook(0x01793e) end(0x017b16)
function void fn01793e()
{
    if (char.velocity.y != knuckles_glide_collision_vY)
    {
        debugLog(stringformat("%d pre %d", knuckles_glide_collision_vY, char.velocity.y))
        u16 gravity = (char.flags & char.flag.UNDERWATER) ? 0x10 : 0x38
        char.velocity.y = knuckles_glide_collision_vY + CrowdControl.calculateGravity(gravity)
        debugLog(stringformat("%d post %d",knuckles_glide_collision_vY, char.velocity.y))
    }
    base.fn01793e()
}

// updates knuckles when still gliding
//# address-hook(0x016fa8) end(0x016fec)
function void fn016fa8()
{
    // if we are disabling jumb abilities then mimic the code that removes
    // knuckles glide state
    if (no_jump_ability_timer > 0)
    {
        // base code section to enter drop state
        // Stop gliding
        char.double_jump_state = 2        // Knuckles glide drop state
        char.state = char.state.KNUX_FALLING
        if (char.velocity.x < 0)
            char.flags |= char.flag.FACING_LEFT
        else
            char.flags &= ~char.flag.FACING_LEFT

        char.velocity.x >>= 2
        char.hitbox_extends.x = char.hitbox.default.x
        char.hitbox_extends.y = char.hitbox.default.y

        #if STANDALONE
        // Perform a ground collision check after updating the hitbox height
        //  -> This prevents getting killed when Knuckles stops gliding just above the floor and there's a blocker object right underneath
        Character.CheckFloorCollision()
        if (D1.s16 < 0)
        {
            char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
        }
        #endif
        return
    }
    base.fn016fa8()
}
