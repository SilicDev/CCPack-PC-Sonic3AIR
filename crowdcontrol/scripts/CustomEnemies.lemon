
function void Jimmy.Update()
{

	if (objA0.base_state == 0x00)
	{
		Jimmy.Init()
	}
	else
	{
		call tableLookupAddress(0x089838, objA0.base_state)
	}

	Enemy.DrawOrUnload()
}

function void Jimmy.Init()
{
	objA0.countdown_value = 0x0800
	objA0.countdown_callback = 0x089926

	setupObjectAttributesFull(0x089b06)

	u32[A0 + 0x30] = 0x089b2c
	objA0.render_flags |= render_flag.FLIP_X
	if (objA0.subtype2c == 2)
		objA0.render_flags |= render_flag.FLIP_Y

	D0.u16 = 0x0400
	u16[A0 + 0x3a] = D0.u16
	objA0.velocity.x = D0.u16
	u16[A0 + 0x3c] = 0x20
	objA0.flags38 &= ~0x08
}

// This function probably needs to be shared with any other custom sprites we do
// (eg, for bumpers to render correctly outside of carnival night?)
function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{

	bool prioFlag = (objA0.sprite_attributes & sprite_attribute.PRIORITY) != 0
	bool flipX = (objA0.render_flags & render_flag.FLIP_X) != 0
	
	if (objA0.update_address == makeCallable(Jimmy.Update))
	{
		// for now, just using the ring animation frame as a test.
		// ideally, should be managed within the object proper so that animation can pause when not moving etc.
		// static_rings.animframe goes 0 to 3
		SpriteHandle spr = Renderer.addSpriteHandle(stringformat("jimmy-%d",static_rings.animframe), px, py, renderQueue)
		spr.setFlipX(flipX)
		spr.setBlendMode(1)
	
		if (static_rings.animframe < 2)
		{
			// for now, just attach the exhaust directly
			// ideally should be a spawned child object that gets left behind rather then being "dragged"
			if (flipX)
			{			
				px -= 28
			}
			else
			{
				px += 28
			}
			spr = Renderer.addSpriteHandle(stringformat("jimmy-exhaust-%d",static_rings.animframe), px, py, renderQueue)
			spr.setBlendMode(1)
		}


		return true
	}
	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}