
constant u8 Asteron.state.init = 0
constant u8 Asteron.state.pause = 2
constant u8 Asteron.state.homing = 4

constant u16 Asteron.pause.duration = 45   // duration of initial pause before homing
constant u16 Asteron.homing.duration = 180 // how long to move towards player before exploding

constant u16 Asteron.spike.duration = 600
constant u16 Asteron.spike.speed = 0x400

function void Asteron.Update()
{
	if (objA0.base_state == Asteron.state.init)
		Asteron.Init()
	else if (objA0.base_state == Asteron.state.pause)
		Asteron.Pause()
	else if (objA0.base_state == Asteron.state.homing)
		Asteron.Home()

	Enemy.DrawOrUnload()
}

function void Asteron.Init()
{
	objA0.countdown_value = 0
	objA0.countdown_callback = 0

	u32[A0 + 0x30] = 0
	objA0.render_flags |= render_flag.FLIP_X
	objA0.render_flags |= render_flag.WORLD
	objA0.render_flags |= render_flag.VISIBLE

	objA0.velocity.x = 0
	objA0.velocity.y = 0
	
	objA0.animation.frame = 0
	objA0.animation.timer = 0
	
	objA0.collision_attributes = collision.size.8x8 | collision.flag.THREAT
	objA0.hitbox_extends.x = 8
	objA0.hitbox_extends.y = 8
	
	objA0.box_size.x = 16
	objA0.box_size.y = 16
	
	objA0.base_state = Asteron.state.pause
	objA0.animation.timer = Asteron.pause.duration
}

function void Asteron.Pause()
{
	
	if (objA0.animation.timer > 0)
	{
		objA0.animation.timer--
		return
	}

	objA0.animation.timer = Asteron.homing.duration
	objA0.base_state = Asteron.state.homing

}

function void Asteron.Home()
{

	if (objA0.animation.timer == 0)
	{
		objA0.update_address = addressof(SmallExplosion.BaseUpdate)
		objA0.base_state = 0

		// spawn spikes
		for (u8 i=0;i<5;i++)
		{
			if (allocDynamicObjectStd())
			{
				objA1.update_address = makeCallable(Asteron.Spike)
				objA1.base_state = 2
				objA1.render_flags |= render_flag.WORLD
				objA1.render_flags |= render_flag.VISIBLE
				objA1.position.x = objA0.position.x
				objA1.position.y = objA0.position.y
				objA1.box_size.x = 8
				objA1.box_size.y = 8
				objA1.animation.frame = i
				objA1.animation.timer = Asteron.spike.duration

				objA1.collision_attributes = collision.size.4x4 | collision.flag.THREAT
				objA1.hitbox_extends.x = 4
				objA1.hitbox_extends.y = 4


				if (i == 0)
				{
					objA1.velocity.x = 0
					objA1.velocity.y = -Asteron.spike.speed
				}
				else if (i < 3)
				{
					objA1.velocity.x = Math.roundToInt(-Asteron.spike.speed * 0.95)
					objA1.velocity.y = Math.roundToInt(-Asteron.spike.speed * 0.31)
				}
				else
				{
					objA1.velocity.x = Math.roundToInt(-Asteron.spike.speed * 0.58)
					objA1.velocity.y = Math.roundToInt(Asteron.spike.speed * 0.81)
				}

				if (i % 2 == 0)
				{
					objA1.render_flags |= render_flag.FLIP_X
					objA1.velocity.x = - objA1.velocity.x					
				}


			}
		}

		return
	}

	objA0.animation.timer--

	if (objA0.animation.timer % 3 == 0)
		objA0.animation.frame = 1-objA0.animation.frame

	// check direction to player
	A1 = 0xffffb000 // player object
	if (objA1.position.x.u16 > objA0.position.x.u16)
		objA0.velocity.x = 0x40
	else if (objA1.position.x.u16 < objA0.position.x.u16)
		objA0.velocity.x = -0x40
	else
		objA0.velocity.x = 0

	if (objA1.position.y.u16 > objA0.position.y.u16 + 4)
		objA0.velocity.y = 0x40
	else if (objA1.position.y.u16 < objA0.position.y.u16 - 4)
		objA0.velocity.y = -0x40
	else
		objA0.velocity.y = 0

	UpdateMovementStraightSimple()
}

function void Asteron.Spike()
{
	if (objA0.animation.timer == 0)
	{
		Object.TriggerUnloading()
		return
	}
	objA0.animation.timer--
	UpdateMovementStraightSimple()
	Enemy.DrawOrUnload()	
}