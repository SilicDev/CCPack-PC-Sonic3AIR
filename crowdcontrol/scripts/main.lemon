
//# script-feature-level(2)

constant u8 object_size = 0x4A

global bool timerA

function void PreFrameUpdate()
{
    if (global.characters == CHARS_TAILS_ALONE)
    {
        tails.control_counter = 600 // don't let the AI mess with us
    }
}

function void CrowdControl.triggerEffect(u32 id, string code, s32 quantity, s32 duration)
{
	// Debug output
	//debugLog(code)

	if (code == "AddRing")
	{
		addRings(quantity)
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
	}
	if (code == "TakeRing")
    {
        if (player.total_rings < quantity)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Not enough rings to take.")
            return
        }
        D0 = -quantity
        AddRings()
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
    }
    if (code == "CharSonic")
    {
		u32 ABackUp = A0
		A0 = 0xffffb000
        CrowdControl.SwapToSonic()
        A0 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
    }
    if (code == "CharTails")
    {
		u32 ABackUp = A0
		A0 = 0xffffb000
        CrowdControl.SwapToTails()
        A0 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
    }
    if (code == "CharKnuckles")
    {
		u32 ABackUp = A0
		A0 = 0xffffb000
        CrowdControl.SwapToKnuckles()
        A0 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
    }
    if (code == "shieldFire")
	{
		u32 ABackUp = A1
		A1 = 0xffffb000
		ItemEffect.ApplyShieldFire()
		A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
	}
	if (code == "shieldBubble")
	{
		u32 ABackUp = A1
		A1 = 0xffffb000
		ItemEffect.ApplyShieldBubble()
		A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
	}
	if (code == "shieldThunder")
	{
		u32 ABackUp = A1
		A1 = 0xffffb000
		ItemEffect.ApplyShieldLightning()
		A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
	}
	if (code == "shieldBlue")
	{
		u32 ABackUp = A1
		A1 = 0xffffb000
		ItemEffect.applyShield(0, addressof(InstaShield.Init), SFX_CLASSICSHIELD)
		A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
		return
	}
    if (code == "Bumper")
    {
        if (allocDynamicObjectStd())
        {
            objA1.update_address = addressof(Bumper.Init)//0x032ef0
            objA1.base_state = 0
            objA1.position.x = camera.position.x
            objA1.position.y = camera.position.y
            objA1.position.x.u16 += System.rand() & 0x3F - 0x20
            objA1.position.y.u16 += System.rand() & 0x3F - 0x20
            objA1.position.x.u16 += (getScreenWidth() / 2)
            objA1.position.y.u16 += (getScreenHeight() / 2)
            if (char.flags & char.flag.FACING_LEFT)
            {
                objA1.position.x.u16 -= 64 + char.box_size.x
            }
            else
            {
                objA1.position.x.u16 += 64
            }
            u16[A1 + 0x2e] = 600
            objA1.countdown_callback = addressof(UnloadObject)
        
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
		return
    }
    if (code == "Eggbox")
    {
        if (allocDynamicObjectStd())
        {
            objA1.update_address = addressof(MonitorIntact.BaseUpdate)//0x01d566
            objA1.base_state = 0
            objA1.subtype2c = 0x02
            objA1.state = 0x02
            objA1.position.x = camera.position.x
            objA1.position.y = camera.position.y
            objA1.position.x.u16 += System.rand() & 0x1F - 0x10
            objA1.position.y.u16 += System.rand() & 0x1F - 0x10
            objA1.position.x.u16 += (getScreenWidth() / 2)
            objA1.position.y.u16 += (getScreenHeight() / 2)
            if (char.flags & char.flag.FACING_LEFT)
            {
                objA1.position.x.u16 -= 32 + char.box_size.x
            }
            else
            {
                objA1.position.x.u16 += 32
            }
            u16[A1 + 0x2e] = 600
            objA1.countdown_callback = addressof(UnloadObject)
        
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
		return
    }
	if (code == "Slap" && u8[0xffffb000 + 0x2e] == 0)
	{
		timerA = true
		u32 ABackUp = A0
		A0 = 0xffffb000
		// u8[0xffffb000 + 0x20] = char.state.GOT_HURT
		// u8[0xffffb000 + 0x05] = 0x04
		// // char.base_state = 
		// ItemEffect.applyShield(0, addressof(InstaShield.Init), SFX_CLASSICSHIELD)
		// A1 = ABackUp

		

		// char.base_state = 0x04
		Character.LandingOnGroundNoSpindash()
		char.flags |= (char.flag.IN_AIR | char.flag.CONTROL_LOCK)
		if (char.flags & char.flag.UNDERWATER)
		{
			char.velocity.x = -0x100
			char.velocity.y = -0x200
		}
		else
		{
			char.velocity.x = -0x500
			char.velocity.y = -0x700
		}
		if (char.flags & char.flag.FACING_LEFT)
		{
			char.velocity.x = -char.velocity.x
		}

		char.groundspeed = 0
		char.state = char.state.GOT_HURT_PANIC
		char.invuln.countdown = 0

		if (char.character == CHARACTER_SONIC)
		{
			// Reset drop dash
			sonic.dropdash_counter = 0
		}
		
		A0 = ABackUp
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
	}
    if (code == "Jimmy")
    {
        if (CrowdControl.SpawnEnemy(makeCallable(Jimmy.Update), 128, -32))
        {
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
		return
    }
    if (code == "Asteron")
    {
        if (CrowdControl.SpawnEnemy(makeCallable(Asteron.Update), 128, -32))
        {
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
		return
    }
    if (code == "Meansteron")
    {
        if (CrowdControl.SpawnEnemy(makeCallable(Meansteron.Update), 128, -32))
        {
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
		return
    }

	// For unknown effects
    base.CrowdControl.triggerEffect(id, code, quantity, duration)
}

// return is unused for now, just adding in case we have additional fail conditions
function bool CrowdControl.SwapToSonic()
{
    char.update_address = 0x010a94
    u16 sprio = u16[0xFFFFB00A]
    char.base_state = 0x00
    char.sprite_attributes = 0x0680 | (0x8000 & sprio)
    global.characters = CHARS_SONIC_ALONE
    CrowdControl.SnapTails(2)
    //Character.Initialization.Sonic()
    return true
}

function bool CrowdControl.SwapToTails()
{
    char.update_address = 0x01365c
    u16 sprio = u16[0xFFFFB00A]
    char.base_state = 0x00
    char.sprite_attributes = 0x06A0 | (0x8000 & sprio)
    global.characters = CHARS_TAILS_ALONE
    CrowdControl.SnapTails(1)
    //Character.Initialization.Tails()
    return true
}

function bool CrowdControl.SwapToKnuckles()
{
    char.update_address = 0x016444
    u16 sprio = u16[0xFFFFB00A]
    char.base_state = 0x00
    char.sprite_attributes = 0x0680 | (0x8000 & sprio)
    global.characters = CHARS_KNUCKLES_ALONE
    CrowdControl.SnapTails(2)
    //Character.Initialization.Knuckles()
    return true
}

function void CrowdControl.SnapTails(u8 character)
{
    u32 address = seekObjectTableFor(addressof(TailsTails.Update), 95, 108)
    if (address == 0)
    {
        address = seekObjectTableFor(addressof(TailsTails.Init), 95, 108)
    }
    if (address != 0)
    {
        //debugLog("Found Tails!")
        if (character == 1)
        {
            u16[address + 0x30] = 0xB000
        }
        if (character == 2)
        {
            u16[address + 0x30] = 0xB04A
        }
        if (character == 3)
        {
            u16[address + 0x30] = 0x0000
        }
    }
}

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
    if (Bumper.onWriteToSpriteTable(px, py, renderQueue))
    {
        return true
    }
    if (EnemyUtils.onWriteToSpriteTable(px, py, renderQueue))
    {
        return true
    }
    return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}


// Dev feature just for testing - must get disabled / removed before release!
#if 1

global bool key2_state = false
global bool key3_state = false
global bool key4_state = false

function void Debugging.debugDraw()
{
	// Call the base implementation (which already uses keys 0 and 1)
	base.Debugging.debugDraw()

	if (Key2)
	{
		if (!key2_state)
		{
			CrowdControl.triggerEffect(-1, "Jimmy", 1, -1)
			key2_state = true
		}
	}
	else
	{
		key2_state = false
	}

	if (Key3)
	{
		if (!key3_state)
		{
			CrowdControl.triggerEffect(-1, "Asteron", 1, -1)
			key3_state = true
		}
	}
	else
	{
		key3_state = false
	}

	if (Key4)
	{
		if (!key4_state)
		{
			CrowdControl.triggerEffect(-1, "Meansteron", 1, -1)
			key4_state = true
		}
	}
	else
	{
		key4_state = false
	}


}

#endif

include EnemySpawn
include Bumpers


//# address-hook(0x01d566) end(0x01d570)
function void MonitorIntact.BaseUpdate()
{
	if (objA0.flags2e != 0)
	{
        objA0.position.x.frac = 1 // unused for any object except the player, using it as a flag
    }
    if (objA0.position.x.frac == 1)
    {
        --u16[A0 + 0x2e]
        if (u16[A0 + 0x2e] == 0)
        {
            UnloadObject()
        }
    }
	// Targets:
	//  - 0x01d57e	-> objA0.base_state = 0x00		-> Initialization
	//  - 0x01d5dc	-> objA0.base_state = 0x02		-> Regular update
	//  - 0x01d716	-> objA0.base_state = 0x04		-> Gets opened
	//  - 0x01d61e	-> objA0.base_state = 0x06		-> Animation update
	//  - 0x01d61a	-> objA0.base_state = 0x08		-> Simply calls "DrawOrUnloadObject"
	call tableLookupAddress(0x01d574, objA0.base_state)
}

function u32 seekObjectTableFor(u32 update_address)
{
    return seekObjectTableFor(update_address, 3, 108)
}

function u32 seekObjectTableFor(u32 update_address, u8 min)
{
    return seekObjectTableFor(update_address, min, 108)
}

function u32 seekObjectTableFor(u32 update_address, u8 min, u8 max)
{
    for (u8 i = min; i < max; i++)
    {
        if (u32[0xFFFFB000 + (object_size * i) + 0x00] == update_address)
        {
            return 0xFFFFB000 + (object_size * i)
        }
    }
    return 0
}