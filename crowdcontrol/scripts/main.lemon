
//# script-feature-level(2)

include EnemySpawn
include Bumpers
include fixes

constant u8 object_size = 0x4A

global bool blue_spheres_jail = false

global bool CrowdControl.paused = false
global bool CrowdControl.prev_paused = false

global u32 invert_directions_timer = 0
global u32 invert_directions_id = 0

//# pre-update-hook
function void PreFrameUpdate()
{
    base.PreFrameUpdate()
    if (global.characters == CHARS_TAILS_ALONE)
    {
        tails.control_counter = 600 // don't let the AI mess with us
    }
    if (global.game_mode == 0x2c && blue_spheres_jail)
    {
        bluespheregame.current_stage = System.rand()
        BlueSphere.setGeneratedStage(bluespheregame.current_stage)
        global.stage_type = 0
        bluespheres.minigame_mode = 1
        global.game_mode = 0x34 // Special Stage
    }
    if (global.game_mode == 0x30 && blue_spheres_jail)
    {
        global.game_mode = 0x0c
        blue_spheres_jail = false
        global.stage_type = 1
    }
    CrowdControl.paused = global.game.paused || Game.isInSkippableCutscene()
    if (!CrowdControl.prev_paused && CrowdControl.paused)
    {
        // Pause Effects
        if (invert_directions_timer > 0)
        {
            CrowdControl.sendResponse(invert_directions_id, CCStatusCode.PAUSED, "")
        }
    }
    if (CrowdControl.prev_paused && !CrowdControl.paused)
    {
        // Resume Effects
        if (invert_directions_timer > 0)
        {
            CrowdControl.sendResponse(invert_directions_id, CCStatusCode.RESUME, "")
        }
    }
    if (!CrowdControl.paused)
    {
        if (invert_directions_timer > 0)
        {
            invert_directions_timer--
            if (invert_directions_timer == 0)
            {
                CrowdControl.sendResponse(invert_directions_id, CCStatusCode.FINISHED, "")
            }
        }
    }
    CrowdControl.prev_paused = CrowdControl.paused
    if (!global.game.paused)
    {
        if (BigArms.Timer > 0)
        {
            BigArms.Timer--
        }
    }
}

function void CrowdControl.triggerEffect(u32 id, string code, s32 quantity, s32 duration)
{
    // Debug output
    //debugLog(code)
    if ((u8[0xffffb000 + 0x05] != base_state.NORMAL && u8[0xffffb000 + 0x05] != base_state.HURT) || global.game.paused)
    {
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "")
        return
    }

    if (code == "AddRing")
    {
        addRings(quantity)
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "TakeRing")
    {
        if (player.total_rings < quantity)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Not enough rings to take.")
            return
        }
        D0 = -quantity
        AddRings()
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "CharSonic")
    {
        u32 ABackUp = A0
        A0 = 0xffffb000
        CrowdControl.SwapToSonic()
        A0 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "CharTails")
    {
        u32 ABackUp = A0
        A0 = 0xffffb000
        CrowdControl.SwapToTails()
        A0 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "CharKnuckles")
    {
        u32 ABackUp = A0
        A0 = 0xffffb000
        CrowdControl.SwapToKnuckles()
        A0 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "shieldFire")
    {
        u32 ABackUp = A1
        A1 = 0xffffb000
        ItemEffect.ApplyShieldFire()
        A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "shieldBubble")
    {
        u32 ABackUp = A1
        A1 = 0xffffb000
        ItemEffect.ApplyShieldBubble()
        A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "shieldThunder")
    {
        u32 ABackUp = A1
        A1 = 0xffffb000
        ItemEffect.ApplyShieldLightning()
        A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "shieldBlue")
    {
        u32 ABackUp = A1
        A1 = 0xffffb000
        ItemEffect.applyShield(0, addressof(InstaShield.Init), SFX_CLASSICSHIELD)
        A1 = ABackUp
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "Bumper")
    {
        if (allocDynamicObjectStd())
        {
            u32 ABackUp = A0
            A0 = 0xffffb000
            objA1.update_address = addressof(Bumper.Init)//0x032ef0
            objA1.base_state = 0
            objA1.position.x = camera.position.x
            objA1.position.y = camera.position.y
            objA1.position.x.u16 += System.rand() & 0x3F - 0x20
            objA1.position.y.u16 += System.rand() & 0x3F - 0x20
            objA1.position.x.u16 += (getScreenWidth() / 2)
            objA1.position.y.u16 += (getScreenHeight() / 2)
            if (char.flags & char.flag.FACING_LEFT)
            {
                objA1.position.x.u16 -= 64 + char.box_size.x
            }
            else
            {
                objA1.position.x.u16 += 64
            }
            u16[A1 + 0x2e] = 600
            objA1.countdown_callback = addressof(UnloadObject)
            A0 = ABackUp
        
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }
    if (code == "Eggbox")
    {
        if (allocDynamicObjectStd())
        {
            u32 ABackUp = A0
            A0 = 0xffffb000
            objA1.update_address = addressof(MonitorIntact.BaseUpdate)//0x01d566
            objA1.base_state = 0
            objA1.subtype2c = 0x02
            objA1.state = 0x02
            objA1.position.x = camera.position.x
            objA1.position.y = camera.position.y
            objA1.position.x.u16 += System.rand() & 0x1F - 0x10
            objA1.position.y.u16 += System.rand() & 0x1F - 0x10
            objA1.position.x.u16 += (getScreenWidth() / 2)
            objA1.position.y.u16 += (getScreenHeight() / 2)
            if (char.flags & char.flag.FACING_LEFT)
            {
                objA1.position.x.u16 -= 32 + char.box_size.x
            }
            else
            {
                objA1.position.x.u16 += 32
            }
            u16[A1 + 0x2e] = 600
            objA1.countdown_callback = addressof(UnloadObject)
            A0 = ABackUp
        
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }
    if (code == "Slap" && u8[0xffffb000 + 0x2e] == 0)
    {
        if (u8[0xffffb000 + 0x2e] != 0)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "")
            return
        }
        CrowdControl.SlapPlayer()
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "Jimmy")
    {
        if (CrowdControl.SpawnEnemy(makeCallable(Jimmy.Update), 128, -32))
        {
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }
    if (code == "Kill")
    {
        u32 ABackUp = A0
        A0 = 0xffffb000
        Character.Die_noSound()
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        A0 = ABackUp
        return
    }
    if (code == "Shove")
    {
        u32 ABackUp = A0
        A0 = 0xffffb000
        char.position.x.u16 += 8
        char.velocity.x = 2000
        char.flags &= ~char.flag.FACING_LEFT
        char.groundspeed = char.velocity.x
        char.hlock_countdown = 15
        char.flags &= ~char.flag.PUSHING
        char.double_jump_state = 0
        char.state = char.state.RUNNING

        playSound(SFX_SPRING)
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        A0 = ABackUp
        return
    }
    if (code == "Reverse")
    {
        u32 ABackUp = A0
        A0 = 0xffffb000
        char.position.x.u16 -= 8
        char.velocity.x = -2000
        char.flags |= char.flag.FACING_LEFT
        char.groundspeed = char.velocity.x
        char.hlock_countdown = 15
        char.flags &= ~char.flag.PUSHING
        char.double_jump_state = 0
        char.state = char.state.RUNNING

        playSound(SFX_SPRING)
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        A0 = ABackUp
        return
    }
    if (code == "BlueSpheres")
    {
        if (global.game_mode != 0x0c || global.zone == 0x0c || global.zone == 0x16 || level.boss_encounter || Game.isInSkippableCutscene())
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "")
            return
        }
        
        fn01bb7e()
        fn02d1cc()
        global.stage_type = 1
        global.game_mode = 0x2c // Blue Sphere Game
        global.in_extra_stage = 1
        blue_spheres_jail = true
        bluespheregame.current_stage = System.rand()
        BlueSphere.setGeneratedStage(bluespheregame.current_stage)
        global.stage_type = 0
        bluespheres.minigame_mode = 1
        global.game_mode = 0x34 // Special Stage
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
        
    }
    if (code == "Asteron")
    {
        if (CrowdControl.SpawnEnemy(makeCallable(Asteron.Update), 128, -32))
        {
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }
    if (code == "Meansteron")
    {
        if (CrowdControl.SpawnEnemy(makeCallable(Meansteron.Update), 128, -32))
        {
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }
    if (code == "GiveEmerald")
    {
        if (global.super_emeralds >= 7 || global.zone == 0x0c)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "")
            return
        }
        if (global.chaos_emeralds >= 7)
        {
            global.traded_emeralds = 0xFF
            global.super_emeralds = 7
        }
        else
        {
            global.chaos_emeralds = 7
        }
        
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "TakeEmerald")
    {
        if (global.chaos_emeralds == 0 || global.zone == 0x0c)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "")
            return
        }
        if (global.super_emeralds > 0)
        {
            global.super_emeralds = 0
            global.traded_emeralds = 0
            Character.cancelSuperTransformation()
            CrowdControl.SlapPlayer()
        }
        else
        {
            global.chaos_emeralds = 0
            Character.cancelSuperTransformation()
            CrowdControl.SlapPlayer()
        }
        if (global.zone != 0x0c)    // No music change in DDZ
        {
            chooseFittingMusic()
        }
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "SpeedShoes")
    {
        if (u8[0xffffb000 + 0x2b] && char.bonus.SPEED_UP)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "")
            return
        }
        u32 ABackUp = A1 //A1 needed for ItemEffect.Apply*
        u32 A2BackUp = A2 //A2 needed for ItemEffect.Apply*, prevents a random write
        A1 = 0xffffb000
        A2 = 0xfffffecc
        ItemEffect.ApplySpeedUp()
        A1 = ABackUp
        A2 = A2BackUp
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "Invincibility")
    {
        if (u8[0xffffb000 + 0x2b] && char.bonus.INVINCIBLE)
        {
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        u32 ABackUp = A1 //A1 needed for ItemEffect.Apply*
        u32 A2BackUp = A2 //A2 needed for ItemEffect.Apply*, prevents a random write
        A1 = 0xffffb000
        A2 = 0xfffffecc
        ItemEffect.ApplyInvincibility()
        A1 = ABackUp
        A2 = A2BackUp
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "VerticalSpring")
    {
        if (allocDynamicObjectStd())
        {
            u32 ABackUp = A0
            A0 = 0xffffb000
            objA1.update_address = addressof(Spring.BaseUpdate)//0x022d06
            objA1.subtype2c = 0x01
            objA1.position.x = camera.position.x
            objA1.position.y = camera.position.y
            objA1.position.x.u16 += (getScreenWidth() / 2)
            objA1.position.y.u16 += (getScreenHeight() / 2) + 52
            if (char.flags & char.flag.FACING_LEFT)
            {
                objA1.position.x.u16 -= 32 + char.box_size.x
                objA1.flags2a &= ~char.flag.FACING_LEFT
            }
            else
            {
                objA1.position.x.u16 += 32
                objA1.flags2a |=  char.flag.FACING_LEFT
            }
            u16[A1 + 0x2e] = 600
            objA1.countdown_callback = addressof(UnloadObject)
            A0 = ABackUp
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }
    if (code == "HorizontalSpring")
    {
        if (allocDynamicObjectStd())
        {
            u32 ABackUp = A0
            A0 = 0xffffb000
            objA1.update_address = addressof(Spring.BaseUpdate)//0x022d06
            objA1.subtype2c = 0x10
            objA1.position.x = camera.position.x
            objA1.position.y = camera.position.y
            objA1.position.x.u16 += (getScreenWidth() / 2)
            objA1.position.y.u16 += (getScreenHeight() / 2) + 32
            if (char.flags & char.flag.FACING_LEFT)
            {
                objA1.position.x.u16 -= 48 + char.box_size.x
                objA1.flags2a &= ~char.flag.FACING_LEFT
            }
            else
            {
                objA1.position.x.u16 += 48
                objA1.flags2a |=  char.flag.FACING_LEFT
            }
            u16[A1 + 0x2e] = 600
            objA1.countdown_callback = addressof(UnloadObject)
            A0 = ABackUp
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }
    if (code == "InvertControls")
    {
        if (invert_directions_timer > 0)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Already running")
            return
        }
        invert_directions_id = id
        
        invert_directions_timer = duration / 1000 * 60
        CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
        return
    }
    if (code == "BigArms")
    {
        if (BigArms.Timer > 0)
        {
            CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Can't spawn second Big Arms")
            return
        }
        if (allocDynamicObjectStd())
        {
            objA1.update_address = makeCallable(BigArms.MainUpdate) //0x074262
            CrowdControl.sendResponse(id, CCStatusCode.SUCCESS, "")
            return
        }
        CrowdControl.sendResponse(id, CCStatusCode.FAILURE, "Object memory is full")
        return
    }

    // For unknown effects
    base.CrowdControl.triggerEffect(id, code, quantity, duration)
}

// return is unused for now, just adding in case we have additional fail conditions
function bool CrowdControl.SwapToSonic()
{
    char.update_address = 0x010a94
    u16 sprio = u16[0xFFFFB00A]
    char.base_state = 0x00
    char.sprite_attributes = 0x0680 | (0x8000 & sprio)
    global.characters = CHARS_SONIC_ALONE
    CrowdControl.SnapTails(2)
    //Character.Initialization.Sonic()
    return true
}

function bool CrowdControl.SwapToTails()
{
    char.update_address = 0x01365c
    u16 sprio = u16[0xFFFFB00A]
    char.base_state = 0x00
    char.sprite_attributes = 0x06A0 | (0x8000 & sprio)
    global.characters = CHARS_TAILS_ALONE
    CrowdControl.SnapTails(1)
    //Character.Initialization.Tails()
    return true
}

function bool CrowdControl.SwapToKnuckles()
{
    char.update_address = 0x016444
    u16 sprio = u16[0xFFFFB00A]
    char.base_state = 0x00
    char.sprite_attributes = 0x0680 | (0x8000 & sprio)
    global.characters = CHARS_KNUCKLES_ALONE
    CrowdControl.SnapTails(2)
    //Character.Initialization.Knuckles()
    return true
}

function void CrowdControl.SnapTails(u8 character)
{
    u32 address = seekObjectTableFor(addressof(TailsTails.Update), 95, 108)
    if (address == 0)
    {
        address = seekObjectTableFor(addressof(TailsTails.Init), 95, 108)
    }
    if (address != 0)
    {
        //debugLog("Found Tails!")
        if (character == 1)
        {
            u16[address + 0x30] = 0xB000
        }
        if (character == 2)
        {
            u16[address + 0x30] = 0xB04A
        }
        if (character == 3)
        {
            u16[address + 0x30] = 0x0000
        }
    }
}

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
    if (Bumper.onWriteToSpriteTable(px, py, renderQueue))
    {
        return true
    }
    if (EnemyUtils.onWriteToSpriteTable(px, py, renderQueue))
    {
        return true
    }
    if (BigArms.onWriteToSpriteTable(px, py, renderQueue))
    {
        return true
    }
    if (RobotnikHead.onWriteToSpriteTable(px, py, renderQueue))
    {
        return true
    }
    return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}


// Dev feature just for testing - must get disabled / removed before release!
#if 1

global bool key2_state = false
global bool key3_state = false
global bool key4_state = false

function void Debugging.debugDraw()
{
    // Call the base implementation (which already uses keys 0 and 1)
    base.Debugging.debugDraw()

    if (Key2)
    {
        if (!key2_state)
        {
            CrowdControl.triggerEffect(-1, "BigArms", 1, 10)
            key2_state = true
        }
    }
    else
    {
        key2_state = false
    }

    if (Key3)
    {
        if (!key3_state)
        {
            CrowdControl.triggerEffect(-1, "Asteron", 1, -1)
            key3_state = true
        }
    }
    else
    {
        key3_state = false
    }

    if (Key4)
    {
        if (!key4_state)
        {
            CrowdControl.triggerEffect(-1, "Meansteron", 1, -1)
            key4_state = true
        }
    }
    else
    {
        key4_state = false
    }


}

#endif

//# address-hook(0x01d566) end(0x01d570)
function void MonitorIntact.BaseUpdate()
{
    if (objA0.flags2e != 0)
    {
        objA0.position.x.frac = 1 // unused for any object except the player, using it as a flag
    }
    if (objA0.position.x.frac == 1)
    {
        --u16[A0 + 0x2e]
        if (u16[A0 + 0x2e] == 0)
        {
            UnloadObject()
        }
    }
    // Targets:
    //  - 0x01d57e    -> objA0.base_state = 0x00        -> Initialization
    //  - 0x01d5dc    -> objA0.base_state = 0x02        -> Regular update
    //  - 0x01d716    -> objA0.base_state = 0x04        -> Gets opened
    //  - 0x01d61e    -> objA0.base_state = 0x06        -> Animation update
    //  - 0x01d61a    -> objA0.base_state = 0x08        -> Simply calls "DrawOrUnloadObject"
    call tableLookupAddress(0x01d574, objA0.base_state)
}

//# address-hook(0x022ef4) end(0x022f40)
function void SpringVertical.Update()
{
    if (objA0.flags2e != 0)
    {
        objA0.position.x.frac = 1 // unused for any object except the player, using it as a flag
    }
    if (objA0.position.x.frac == 1)
    {
        --u16[A0 + 0x2e]
        if (u16[A0 + 0x2e] == 0)
        {
            UnloadObject()
        }
    }
    SpringVertical.updateInternal(false)
}

//# address-hook(0x023050) end(0x0230d8)
//# alias(SpringHorizontal.Check) deprecated
function void SpringHorizontal.Update()
{
    if (objA0.flags2e != 0)
    {
        objA0.position.x.frac = 1 // unused for any object except the player, using it as a flag
    }
    if (objA0.position.x.frac == 1)
    {
        --u16[A0 + 0x2e]
        if (u16[A0 + 0x2e] == 0)
        {
            UnloadObject()
        }
    }
    base.SpringHorizontal.Update()
}

//# address-hook(0x0010de) end(0x001118)
function void UpdateControllers()
{
    #if STANDALONE
    {
        // The following would be the correct implementation for Oxygen,
        // but we don't do that here and rather in "waitForNextFrame" to ensure that controllers get updated each frame
    /*
        control.pad1.state = Input.getController(0)
        control.pad1.pressed = control.pad1.state & ~Input.getControllerPrevious(0)
        control.pad2.state = Input.getController(1)
        control.pad2.pressed = control.pad2.state & ~Input.getControllerPrevious(1)
    */
    }
    #else
    {
        A0 = 0xfffff604        // Address of "control.pad1"
        A1 = 0xa10003        // Hardware address for physical controller port 1

        for (u8 i = 0; i < 2; ++i)
        {
            // Two loops, one for each controller port
            u8[A1] = 0
            D0.u8 = (u8[A1] << 2) & (CONTROL_A | CONTROL_START)

            u8[A1] = 0x40
            D1.u8 = u8[A1] & (CONTROL_B | CONTROL_C)
            if (invert_directions_timer > 0 && !CrowdControl.paused)
            {
                u8 temp = 0
                if (u8[A1] & CONTROL_UP)
                {
                    temp |= CONTROL_DOWN
                }
                if (u8[A1] & CONTROL_DOWN)
                {
                    temp |= CONTROL_UP
                }
                if (u8[A1] & CONTROL_LEFT)
                {
                    temp |= CONTROL_RIGHT
                }
                if (u8[A1] & CONTROL_RIGHT)
                {
                    temp |= CONTROL_LEFT
                }
                D1.u8 |= temp
            }
            else {
                D1.u8 |= u8[A1] & CONTROL_DPAD
            }

            D0.u8 = (D0.u8 | D1.u8) ^ 0xff        // Currently pressed buttons
            D1.u8 = u8[A0] ^ D0.u8                // Clearing buttons pressed in previous storage

            u8[A0] = D0.u8                    // Set button held states
            u8[A0+1] = D1.u8 & D0.u8        // Set button pressed states

            A0 += 2        // To next input storage address
            A1 += 2        // To next controller port address
        }
    }
    #endif
}

function void Standalone.onLevelStart() 
{
    BigArms.Timer = 0
    base.Standalone.onLevelStart()
}

function void Standalone.onRestartAtCheckpoint() 
{
    BigArms.Timer = 0
    base.Standalone.onRestartAtCheckpoint()
}

function void waitForNextFrame()
{
    base.waitForNextFrame()
    if (invert_directions_timer > 0 && !CrowdControl.paused)
    {
        u8 temp = control.pad1.state & (CONTROL_ABC | CONTROL_START)
        if (control.pad1.state & CONTROL_UP)
        {
            temp |= CONTROL_DOWN
        }
        if (control.pad1.state & CONTROL_DOWN)
        {
            temp |= CONTROL_UP
        }
        if (control.pad1.state & CONTROL_LEFT)
        {
            temp |= CONTROL_RIGHT
        }
        if (control.pad1.state & CONTROL_RIGHT)
        {
            temp |= CONTROL_LEFT
        }
        control.pad1.state = temp
        control.pad1.pressed = control.pad1.state & ~Input.getControllerPrevious(0)
        
        temp = control.pad2.state & (CONTROL_ABC | CONTROL_START)
        if (control.pad2.state & CONTROL_UP)
        {
            temp |= CONTROL_DOWN
        }
        if (control.pad2.state & CONTROL_DOWN)
        {
            temp |= CONTROL_UP
        }
        if (control.pad2.state & CONTROL_LEFT)
        {
            temp |= CONTROL_RIGHT
        }
        if (control.pad2.state & CONTROL_RIGHT)
        {
            temp |= CONTROL_LEFT
        }
        control.pad2.state = temp
        control.pad2.pressed = control.pad2.state & ~Input.getControllerPrevious(1)
    }
}

function void CrowdControl.SlapPlayer()
{
    u32 ABackUp = A0
    A0 = 0xffffb000
    // u8[0xffffb000 + 0x20] = char.state.GOT_HURT
    // u8[0xffffb000 + 0x05] = 0x04
    // // char.base_state = 
    // ItemEffect.applyShield(0, addressof(InstaShield.Init), SFX_CLASSICSHIELD)
    // A1 = ABackUp

    // char.base_state = 0x04
    Character.LandingOnGroundNoSpindash()
    char.flags |= (char.flag.IN_AIR | char.flag.CONTROL_LOCK)
    if (char.flags & char.flag.UNDERWATER)
    {
        char.velocity.x = -0x100
        char.velocity.y = -0x200
    }
    else
    {
        char.velocity.x = -0x200
        char.velocity.y = -0x400
    }
    if (char.flags & char.flag.FACING_LEFT)
    {
        char.velocity.x = -char.velocity.x
    }

    char.groundspeed = 0
    char.state = char.state.GOT_HURT_PANIC
    char.invuln.countdown = 120

    if (char.character == CHARACTER_SONIC)
    {
        // Reset drop dash
        sonic.dropdash_counter = 0
    }
    
    A0 = ABackUp
}

function u32 seekObjectTableFor(u32 update_address)
{
    return seekObjectTableFor(update_address, 3, 110)
}

function u32 seekObjectTableFor(u32 update_address, u8 min)
{
    return seekObjectTableFor(update_address, min, 110)
}

function u32 seekObjectTableFor(u32 update_address, u8 min, u8 max)
{
    for (u8 i = min; i < max; i++)
    {
        if (u32[0xFFFFB000 + (object_size * i) + 0x00] == update_address)
        {
            return 0xFFFFB000 + (object_size * i)
        }
    }
    return 0
}

function void unloadChildrenAt(u32 update_address, bool recursive)
{
    for (u8 i = 3; i < 110; i++)
    {
        u32 addr = 0xFFFFB000 + (object_size * i)
        u32 parent = 0xFFFF0000 + u16[addr + 0x46]
        if (parent == update_address)
        {
            if (recursive)
            {
                unloadChildrenAt(addr, true)
            }
            unloadObjectAt(addr)
        }
    }
}